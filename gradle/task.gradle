/**
 * sequence test:
 * 1. ./gradlew taskA             // execute sequence : taskB taskA taskC
 * 2. ./gradlew taskB taskA       // execute sequence : taskB taskA taskC
 * 3. ./gradlew taskA taskB taskA // execute sequence : taskB taskA taskC
 * 4. ./gradlew taskC taskA       // execute sequence : taskB taskA taskC
 */
task taskA {
    dependsOn(["taskB"])

    finalizedBy(['taskC'])

    doLast {
        println name + " doLast."
        println MY_VAR
        println MY_MAP.get("key1")
    }

    println name + " evaluate phase."
}

task taskB {
    //you can give value to input/output via
    inputs
    outputs

    doFirst {
        println name + " doFirst."
        println exampleVar // from gradle.properties
    }
}

task taskC(type: taskCType) {
    //give value to the task via input/output specified in 'taskCType'
    var = VERSION
    someFile = new File(project.getBuildDir().absolutePath + "/taskC.result")
}

class taskCType extends DefaultTask {

    @Input
    String var

    @OutputFile
    File someFile

    @TaskAction
    void doJob() {
        //using input then change output at your action depends on your own logic
        someFile.write(var)
        println name + " " + var + " " + someFile.absolutePath
    }
}